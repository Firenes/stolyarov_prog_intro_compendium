Односвязные списки

Односвязный список – список, состоящий из звеньев, каждое из которых,
представляя собой переменную типа "запись", в качестве одного из своих
полей имеет указатель на следующий элемент списка.
Последний элемент списка в этом поле содержит значение `nil`, чтобы
обозначить, что больше элементов нет.

"Односвязный" – на каждый элемент приходится одно поле с одним указателем.
Также в списке выстроена лишь одна цепочка связей из указателей.

         ------       ------       -------
first -> | 25 |   |-> | 36 |   |-> | 149 |
         ------   |   ------   |   -------
         |    | --|   |    | --|   | nil |
         ------       ------       -------

Элемент списка по идее должен выглядеть так::

------------------------
type
	item = record
		data: integer;
		next: ^item; { ошибка! тип item ещё не описан }
	end;
------------------------

но Pascal не разрешает использовать имя описываемого типа при описании его
собственный полей, поэтому надо сделать так:

------------------------
type
	itemptr = ^item;
	item = record
		data: integer;
		next: itemptr;	
	end;
------------------------

Можно дать отдельное имя типа указателя на `item` – `itemptr` до того, как
опишется сам тип `item`.

Описать указатель на список можно так:

------------------------
var
	first: itemptr;
------------------------

Сам список выше можно реализовать так:

------------------------
begin
	new(first);
	first^.data := 25;
	new(first^.next);
	first^.next^.data := 36;
	new(first^.next^.next);
	first^.next^.next^.data := 149;
	first^.next^.next^.next := nil;
end.
------------------------

Для работы со списками используют один из двух способов:
– Элементы заносят всегда в его начало (это делается с помощью
  вспомогательного указателя);
– Хранятся два указателя – на начало и конце списка, а элементы заносят в
  конец списка.


Для тренировки есть две задачи:

1. Написать программу, которая читает целые числа из потока стандартного
   ввода до возникновения ситуации "конца файла", после чего печатает все
   введёные числа в обратном порядке. Количество чисел заранее неизвестно,
   вводить явные ограничения на это количество запрещается.

2. Написать программу, которая читает целые числа из потока стандартного
   ввода до возникновения ситуации "конца файла", после чего дважды печатает
   все введёные числа в том порядке, в котором они были введены. Количество
   чисел заранее неизвестно, вводить явные ограничения на это количество
   запрещается.


Решение задачи 1 см 2.10.4_reversed_numbers.pas.

Объяснение:

Добавление элемента в начало односвязанного списка происходит в 3 этапа:
– Используется вспомогательный указатель, создавая новый элемент списка;
– Элемент заполняется. В указатель на следующий элемент кладётся адрес
  на элемент, который находится в начале списка;
– Новый элемент становится первым в списке. Это делается присваиванием его
  адреса в указатель, хранящий адрес первого элемента.

Стоит учесть, что при работе с пустым списком, обязательно нужно пометить
его nil.

С такой трёхшаговой процедурой связано одно свойство:
Для случая пустого списка последовательность действий по добавлению нового
элемента полностью совпадает с последовательностью действий по добавлению
нового элемента в начало списка, уже содержащего элементы.

В рамках 1-ой задачи нет необходимости освобождать память, т.к. она сама
освобождается по завершению программы. В более сложных программах, где
стоятся список за списком это надо делать обязательно.

Удалять его можно двумя способами:
--------------------------------
while first <> nil do
begin
	tmp := first^.next; { запоминаем адрес следующего }
	dispose(first);     { уничтожаем первый элемент }
	first := tmp        { список теперь начинается со следующего }
end;
--------------------------------

--------------------------------
while first <> nil do
begin
	tmp := first;       { запоминаем адрес первого }
	first := tmp^.next; { исключаем его из исписка }
	dispose(tmp)        { удаляем его из памяти }
end;
--------------------------------


Решение задачи 2 см 2.10.4_numbers.pas
