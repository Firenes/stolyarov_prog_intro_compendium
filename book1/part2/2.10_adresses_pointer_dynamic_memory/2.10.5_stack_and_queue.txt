Стек и очередь

Стек и очередь определяются не как структуры данных, а как операция и как
с этой операцией работать.

Стек и очередь представляют собой некий абстрактный "объект", обеспечивающий
хранение значений определённого типа.
Добавление обеспечивается 2 базовыми операциями: добавлением и извлечением.

Разница в том, в каком порядке происходит извлечение:
- Очередь – извлечение в том же порядке, что и заносилось.
  FIFO (first in, first out).
- Стек – извлечение последнего.
  LIFO (last in, first out).

Самый простой вариант реализации стека – односвязный список. Элементы всегда
добавляются в начало и оттуда же извлекаются.

Очередь также можно реализовать с помощью односвязанного списка, где
элементы будут добавляться в конец списка, а извлекаться из начала.

Реализация механизма не так важна, в отличии от того, что они делают.
Это позволяет создавать набор подпрограмм, который реализуют необходимые
операции. При этом, изменяя реализацию общая суть менять не должна.

Такие вещи называются "интерфейсами" (API – application programming
interface).
Удачный интерфейс – изменния деталей реализации не повлекут к изменениям
самого интерфейса.

Один из подходов хороших интерфейсов – сначала придумать именно интерфейсы
исходя из набора операций, которых ожидает пользователь, а в дальнейшем
написать реализацию.

Опишем интефейс для стека longint'ов:

---------------------------------------------
type
	StackOfLongints = ;

procedure SOLInit(var stack: StackOfLongints);
begin
end;

procedure SOLPush(var stack: StackOfLongints; n: longint);
begin
end;

procedure SOLPop(var stack: StackOfLongints; var n: longint);
begin
end;

function SOLIsEmpty(var stack: StackOfLongints): boolean;
begin
end;
---------------------------------------------

Сам стек обозначен типом StackOfLongints, чтобы не зависеть от реализации.
Передача стека происходит через var-переменную, что бы не копировать стек,
т.к. он может быть гигантских размеров.
`SOLInit` – инициализирует стек;
`SOLPush` – пушит в стек значение n;
`SOLPop` – передаёт через var-переменную извлечённое значение. Нюанс в том,
что нельзя извлечь значение из пустого стека, поэтому необходимо сначала
сделать проверку не пустой ли стек с помощью функции `SOLIsEmpty`.


Реализацию см 2.10.5_sol.pas

Многие программисты предпочитают в случаях, когда при вызове подпрограммы
возможна ошибка оформлять её не как процедуру, а как функцию, возвращающую
булю.
В таком случае `SOLPop` мог бы выглядеть так:

---------------------------------------------
function SOLPop(var stack: StackOfLongints; n: longint): boolean;
var
	temp: LongIntItemPtr;
begin
	if stack = nil then
	begin
		SOLPop := false;
		exit
	end;

	n := stack^.data;
	temp := stack;
	stack := stack^.next;
	dispose(temp);
	SOLPop := true
end;
---------------------------------------------

Это позволило бы описать цикл из примера короче:

---------------------------------------------
while SOLPop(s, n) do
	writeln(n)
---------------------------------------------

Основной недостаток такого примера – функция имеет побочный эффект.
От таких приёмов лучше воздерживаться, пока специфика Си не заставит. 


Опишем интерфейс для очереди:

---------------------------------------------
type
	QueueOfLongints = ;

procedure QOLInit(var queue: QueueOfLongints);
begin
end;

procedure QOLPut(var queue: QueueOfLongints; n: longint);
begin
end;

procedure QOLGet(var queue: QueueOfLongints; var n: longint);
begin
end;

function QOLIsEmpty(var queue: QueueOfLongints): boolean;
begin
end;
---------------------------------------------

Список интерфейса схож с StackOfLongints за исключением, что делаем не push
и pop, а put и get.

Реализацию см. 2.10.5_qol.pas
