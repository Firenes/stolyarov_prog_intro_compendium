Проход по списку указателем на указатель

Есть список целых чисел и нужно удалить из него все элементы, содержащие
отрицательные значения.
Для удаления элемента из списка необходимо изменить тот указатель, который
на него указывает.
Если удаляемый элемент не первый, то изменять нужно значение указателя next
в предыдущем элементе списка.
Если первый, то изменять нужно указатель first.

Указатель на указатель можно сделать следующим образом:
---------------------------------------
var
	pp: ^itemptr;
---------------------------------------

Переменная `pp` хранит адрес указателя на item и может хранить как адрес
first, так и next.
Т.е. он в каждый момент времени указывает на указатель, в котором
располагается адрес текущего звена списка в цикле.

Начальное присваивание первого элемента:
---------------------------------------
pp := @first;
---------------------------------------

Последующего:
---------------------------------------
pp := @(pp^^.next);
---------------------------------------

pp^^ – pp^ – указывает на указатель текущего элемента, а p^^ – сам элемент.

Переход к следующему элементу происходит только, когда не удалили текущий.

Условие окончание цикла, когда наткнулись на nil, т.е. `pp^ <> nil`.

Итоговый вид цикла:
---------------------------------------
pp := @first;
while pp^ <> nil do
begin
	if pp^^.data < 0 then
	begin
		tmp := pp^;
		pp^ := pp^^.next;
		dispose(tmp)
	end
	else
		pp := @(pp^^.next)
end;
---------------------------------------


С помощью указателя на указатель можно не только удалять, но и вставлять
элементы в любую позицию списка.

---------------------------------------
new(tmp);
tmp^.next := pp^;
tmp^.data := n;
pp^ = tmp;
---------------------------------------


Также можно работать с отсортированным списком вставляя элемент нужную
позицию:
---------------------------------------
pp := @first;
while (pp^ <> nil) and (pp^^.data < n) do
	pp := @(pp^^.next);
new(tmp);
tmp^.next := pp^;
tmp^.data := n;
pp^ := tmp;
---------------------------------------

С помощью цикла ищется элемент, перед которым нужно вставить новый.


Есть нюанс с работой с условием в цикле выше.
Если pp^ вдруг окажется nil, то выражение должно вызвать крэш программы.
Чтобы этого не произошло, то во Free Pascal используется "ленивая"
семантика, при которой вычисление второй части выражении происходить
не будет, поскольку выражение перед логической "и" уже ложно.

Чтобы переключения с "ленивой" семантики на "классическую" во Free Pascal
используется директива `{$B+}`. Чтобы выключить – `{$B-}`.
По умолчанию стоит "ленивая" – `{$B-}`.
Включать "классическую" не стоит.
