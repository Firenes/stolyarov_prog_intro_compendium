Преобразование типов

При присваивании числа 15 к переменной типа real, на выходе будет 15.0.
Это является преобразованием типа.

В случае преобразования целое число в дробное – неявное преобразование типа.
Компилятор сам преобразовывает тип.

Компилятор неявно преобразовывает:
– целочисленные типы друг в друга (integer, longint, int64, word, ...);
– целочисленные типы в типы с плавующей точкой;
– типы с плавующей точкой в типы с плавующей точкой
  (real, single, double, extended);
– тип символа в тип строки (char -> string).

При этом копмилятор не будет преобразовывать тип с плавующей точкой в
целочисленный. Ошибка будет на уровне компиляции.

Преобразовать дровное число в целое можно несколькими способами, поэтому
сделать это надо вручную.

Есть два способа это сделать:
– отбрасывание дробной части (метод – trunc());
– математичесткое округление (метод – round()).

------------------------------------ 
var
	i, j: integer;
	r: real;

begin
	r := 15.75;
	i := trunc(r);
	j := round(r);
end.
------------------------------------ 

В i – 15. В j – 16.

Под капотом round() и truck() не преобразовывают типы, а делают вычисление.

Неявным преобразованиям могут подвергаться значения выражения, но не
переменные.
При передачи через var-параметр тип переменной должен совпадать с типом
параметра. Если параметр типа integer, то longint не получится передать.

Дело в том, что машинный код подпрограммы сформирован в расчёте на тип
integer и не знает ничего о том, что происходит в точке вызова.
Если бы компилятор позволял передавать другой тип в переменную, то
подпрограмма никогда бы не узнала, что ей подсовывают другой тип.

При это преобразование значения компилятор делает в точке вызова.
А тело подпрограммы получает необходимый тип.


Явные преобразования типов.
Такие преобразования возможно как для значений выражения, так и для
переменных.
Преобразование напоминает вызов функции, но вмето имени функции, вызываем
имя тип.

integer('5') – 53, двухбайтное знаковое;
byte('5') – 53, однобайтовое беззнаковое.

------------------------------------ 
var
	c: char;
begin
	byte(c) := 65;
...
------------------------------------ 

Явно преобразовывать во Free Pascal можно в двух случаях:
– Порядковые типы можно преобразовывать без ограничения
  (целые числа, char, boolean, перечисляемые типы);
– Типы имеющие одинаковый размер машинного предсталения.

Преобразование типов переменных, то для них работает только второй случай.

Явное представление стоит использовать с осторожностью.
К примеру, код символа лучше доставать через функцию ord(), а создавать
символ по коду через chr().
Если нет уверенности в использовании явного преобразования типа или можно
обойтись без него, то лучше его вообще не испольщовать.

